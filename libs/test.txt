// this is a toplevel source file. Give as command line argument to j1comp.
BRA:main // skip over function definitions
#include(CPU.txt)
#include(system.txt)
#include(system.ASCII.txt)

VAR:offset=0

:ok	system.ascii.o system.emit system.ascii.k system.emit system.emit.cr ;
:err	system.ascii.e system.emit system.ascii.r system.emit system.ascii.r system.emit system.emit.cr ;

:main

	// ============================================
	// === test initial stack depth 0
	// ============================================
	core.depth 0 = IF ok ELSE err ENDIF

	IF_BRA_BC_test
	looptestOuter
	system.terminate

:IF_BRA_BC_test
BRA:label2
	system.ascii.a

	// ============================================
	// === test BZ, BRA
	// ============================================
  :label1
	// compare with end-of-loop
	dup system.ascii.z 1 + core.lessThanSigned BZ:label2
	1 +
	BRA:label1
  :label2
	
	// ============================================
	// === test BEGIN ... UNTIL construct
	// ============================================
	system.ascii.A
	BEGIN
		// ============================================
		// === test IF ... ELSE ... ENDIF construct
		// ============================================
		dup // value to emit
		dup 1 and 1 = IF
		    0x20 core.or // odd characters: to lower case
		ELSE
		    dup system.emit // even characters: write twice
		ENDIF	    
		system.emit

		// increase loop var
		1 +

		// exit condition
		dup system.ascii.Z 1 + =
	UNTIL
	drop // clean up loop var
	system.emit.cr
;

:looptestOuter
	// ============================================
	// === test variable
	// ============================================
	-3 3 DO	
		dup offset !		
		looptest
	LOOP
;

:looptest
	// ============================================
	// === test DO-LOOP construct
	// ============================================
	0				// i loop start
	10				// i loop end 
	DO				// for i
		>r				// save i
		system.ascii.a r@ +		// j loop start
		system.ascii.z 1 + 9 - r@ +		// j loop end
		DO	// for j
			dup offset @ + 
			system.emit
		LOOP
		system.ascii.cr system.emit
		system.ascii.nl system.emit
	r>				// restore loop var, clear return stack
	LOOP
;



:start
0x40	// @
:nextChar
dup 0x1000 io!

dup 0x60 = IF 
     drop 
     BRA:start 
ENDIF
1 +
BRA:nextChar
BRA:start
/*

:myFun dup drop ;
::deadbeef 0xDEADBEEF swap drop ;
deadbeef deadbeef
VAR:gumbo=1024
VAR:gumbo2=1025
VAR:gumbo3=1026
gumbo dup @ 1 + ! gumbo2 gumbo3

IF
-1
ELSE
1
ENDIF
core.noop
:hello
BRA:hello
*/
1
DO
LOOP