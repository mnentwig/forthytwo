// ########################################################################
// # The file flm.txt is auto-generated by extractor.pl from flm.c
// # Its purpose is a system library for 32-bit pseudo-float math.
// # Public symbols are prefixed with the library name:
// # - flm.pack (build float from exponent and mantissa)
// # - flm.unpack (split float into exponent and mantissa)
// # - flm.add (add two floats)
// ########################################################################
// # (note, private symbol xyz is prefixed as __flm.xyz)
#include(math.txt) // need signed multiplication
#ENABLE_FLOAT_LITERALS // instruct parser to convert numbers with decimal point to flm format
::flm.PI 3.1415926535 ;
::__unpackedNegativeMantissa_mustShiftDown 0x7E000000 dup >r core.and r> = core.invert ;
::__unpackedNegativeMantissa_mustShiftUp 0x01000000 core.and ;
::__unpackedPositiveMantissa_mustShiftDown 0x7E000000 core.and ;
::__unpackedPositiveMantissa_mustShiftUp 0x01000000 core.and 0 = ;
:__unpackedNormalize_negative
dup __unpackedNegativeMantissa_mustShiftDown 
IF
	swap 1 +
	swap 1 core.rshift
	0x80000000 core.or
	BRA:__unpackedNormalize_negative
ENDIF
dup __unpackedNegativeMantissa_mustShiftUp
IF
 	// check whether exponent is already at clip limit
	core.over 0x2F core.and 0x20 core.equals core.invert
	IF
		swap -1 +
		swap 1 core.lshift
		BRA:__unpackedNormalize_negative
	ENDIF
ENDIF
;
:__unpackedNormalize_positive
dup __unpackedPositiveMantissa_mustShiftDown 
IF
	swap 1 +
	swap 1 core.rshift
	BRA:__unpackedNormalize_positive
ENDIF
dup __unpackedPositiveMantissa_mustShiftUp
IF
 	// check whether exponent is already at clip limit
	core.over 0x2F core.and 0x20 core.equals core.invert
	IF
		swap -1 +
		swap 1 core.lshift
		BRA:__unpackedNormalize_positive
	ENDIF
ENDIF
;
// returns number with n bits set, starting from bit 31
::__flm.nMsbMask core.invert 33 + 
1 swap core.lshift 
0 core.invert + core.invert ;

//arithmetic right shift (MSB replica stays in place)
:flm.rshiftArith
// special case:shift by 0 
core.dup 0 core.equals IF drop ; ENDIF
>r // store shift amount
r@ 32 core.lessThanSigned 
IF
	dup 0 <s 
	IF
		// shift and set new MSBs
		r@ __flm.nMsbMask swap r> core.rshift core.or ;
	ENDIF
	r> core.rshift ;
ENDIF
r> drop // clean up shift amount
0 core.lessThanSigned BZ:__flm.rshiftArithResultAllZero
0 core.invert ; // return 0xFFFFFFFF
:__flm.rshiftArithResultAllZero
0 ; // return 0x00000000

// 1: exponent; 0: mantissa
:__flm.unpackedNormalize
dup 
IF // mantissa is non-zero? YES
	swap // 0: exponent; 1: mantissa
	// ===fix exponent below -32===
	BEGIN
		/*exponent*/ dup -32 core.lessThanSigned 
    	WHILE
		1 + swap 1 flm.rshiftArith swap
	REPEAT
	// ===fix exponent above 31===
	BEGIN
		/*exponent*/ dup 31 swap core.lessThanSigned 
    	WHILE
		/*-1*/ 0 core.invert + swap 1 core.lshift swap
	REPEAT
	swap // 0: mantissa; 1: exponent
	/*mantissa*/ dup 0x80000000 core.and 
	IF // mantissa is negative? YES
		__unpackedNormalize_negative     
	ELSE // mantissa is negative? NO
		__unpackedNormalize_positive
	ENDIF // mantissa is negative?
ELSE // mantissa is non-zero? NO
	swap drop 0
ENDIF // mantissa is zero?
;
:flm.unpack
// === mask to return stack ===
0x0000003F >r
// === extract exponent ===
dup r@ core.and 
// === negative sign extension ===
dup 0x00000020 core.and IF
0xFFFFFFC0 core.or 
ENDIF

// === extract mantissa ===
swap r> core.invert core.and
6 flm.rshiftArith ;

:flm.unpackUp6
// === mask to return stack ===
0x0000003F >r
// === extract exponent ===
dup r@ core.and 
// === negative sign extension ===
dup 0x00000020 core.and IF
0xFFFFFFC0 core.or 
ENDIF

// === extract mantissa, shifted 6 bits up ===
swap r> core.invert core.and ;

:flm.pack
6 core.lshift
swap
0x0000003F core.and
core.or
;
VAR:__flm.mantissaA=0
VAR:__flm.mantissaB=0
VAR:__flm.exponentA=0
VAR:__flm.exponentB=0


:flm.add
//=== zero check (handle as special case because zero exponent would impair accuracy) ===
dup 0 core.equals IF core.drop core.return ENDIF // argA zero check
over 0 core.equals IF core.nip core.return ENDIF // argA zero check
flm.unpack
'__flm.mantissaA ! '__flm.exponentA !
flm.unpack
'__flm.mantissaB ! '__flm.exponentB !

// === decide target exponent ===
'__flm.exponentA @ '__flm.exponentB @ <s 
IF
'__flm.exponentB @ 
ELSE
'__flm.exponentA @
ENDIF
>r

'__flm.mantissaA @
'__flm.exponentA @ core.invert 1 + r@ + flm.rshiftArith

'__flm.mantissaB @
'__flm.exponentB @ core.invert 1 + r@ + flm.rshiftArith

// === mantissa A and B are now aligned, common exponent in r@ ===
core.plus

r>		 // recall mantissa
swap		 // restore unpacked order

__flm.unpackedNormalize
flm.pack
;
:flm.mul
flm.unpackUp6
'__flm.mantissaA ! '__flm.exponentA !
flm.unpackUp6
'__flm.mantissaB ! '__flm.exponentB !

// === result exponent ===
'__flm.exponentA @ '__flm.exponentB @ + 20 +
// === result mantissa ===
'__flm.mantissaA @ '__flm.mantissaB @ math.s32*s32x2 drop
__flm.unpackedNormalize
flm.pack
;
:flm.__forceNormalizePositive
/*mantissa*/core.dup 0 core.equals core.invert
IF
	0x40000000 core.pushR // create mask
	BEGIN
		dup core.fetchR core.and 0 core.equals
	WHILE
		1 core.lshift swap
		0 core.invert core.plus swap 
	REPEAT
	core.popR core.drop // clean up mask
ENDIF
;
VAR:__flm.result=0
VAR:__flm.negFlag=0
:flm.__divSignHandling 
dup 0 core.lessThanSigned // is the given mantissa negative? 
IF 
	core.invert 1 core.plus // flip sign
	'__flm.negFlag dup @ core.invert swap ! // flip negFlag
ENDIF 
;

:flm.div
// === init ===
0 '__flm.negFlag !
0 '__flm.result ! 
// === prepare arg B (divisor) ===
flm.unpackUp6 
flm.__divSignHandling 
flm.__forceNormalizePositive '__flm.mantissaB ! '__flm.exponentB !
// === prepare arg A (dividend) ===
flm.unpackUp6 
flm.__divSignHandling '__flm.mantissaA ! '__flm.exponentA !
//=== init mask ===
0x40000000 core.pushR
// === prepare stack 0:a 1:b
'__flm.mantissaB @ 
'__flm.mantissaA @
BEGIN
	/*a*/ dup 0 core.equals core.invert // a != 0
	core.fetchR 0 core.equals core.invert  // mask != 0
	core.and
WHILE
	core.over core.over // duplicate B and A for comparison
	swap core.lessThanUnsigned core.invert // b >= a?
	IF
		'__flm.result dup @ core.fetchR core.or swap ! // result += mask
		core.over core.invert 1 core.plus core.plus // a -= b
	ENDIF
	1 core.lshift 	// a <<= 1
	core.popR 1 core.rshift core.pushR // mask >>= 1
REPEAT
/*clean up a*/core.drop /*clean up b*/core.drop /*clean up mask*/core.popR core.drop
// === result exponent ===
'__flm.exponentA @ '__flm.exponentB @ core.invert core.plus -29 core.plus
// === result mantissa ===
'__flm.result @
// === restore sign ===
'__flm.negFlag @ IF core.invert 1 core.plus ENDIF
__flm.unpackedNormalize
flm.pack
;
:flm.int2flt
0 swap // insert exponent (argument becomes mantissa)
__flm.unpackedNormalize
flm.pack
;
:flm.flt2int
flm.unpack swap dup
0 core.lessThanSigned IF core.invert 1 core.plus flm.rshiftArith ELSE core.lshift ENDIF
;
:flm.negate
flm.unpack
core.invert 1 core.plus
__flm.unpackedNormalize
flm.pack
;
//simulator has built-in print() for flm format (avoids the need for large on-system crt library)
::flm.sim.printFlm 0x1006 io! ;
