// ########################################################################
// # The file flm.txt is auto-generated by extractor.pl from flm.c
// # Its purpose is a system library for 32-bit pseudo-float math.
// # Public symbols are prefixed with the library name:
// # - flm.pack (build float from exponent and mantissa)
// # - flm.unpack (split float into exponent and mantissa)
// # - flm.add (add two floats)
// ########################################################################
// # (note, private symbol xyz is prefixed as __flm.xyz)
::__unpackedNegativeMantissa_mustShiftDown 0x7E000000 dup >r core.and r> = core.invert ;
::__unpackedNegativeMantissa_mustShiftUp 0x01000000 core.and ;
::__unpackedPositiveMantissa_mustShiftDown 0x7E000000 core.and ;
::__unpackedPositiveMantissa_mustShiftUp 0x01000000 core.and 0 = ;
:__unpackedNormalize_negative
dup __unpackedNegativeMantissa_mustShiftDown 
IF
	swap 1 +
	swap 1 core.rshift
	0x80000000 core.or
	BRA:__unpackedNormalize_negative
ENDIF
dup __unpackedNegativeMantissa_mustShiftUp
IF
 	// check whether exponent is already at clip limit
	core.over 0x2F core.and 0x20 core.equals core.invert
	IF
		swap -1 +
		swap 1 core.lshift
		BRA:__unpackedNormalize_negative
	ENDIF
ENDIF
;
:__unpackedNormalize_positive
dup __unpackedPositiveMantissa_mustShiftDown 
IF
	swap 1 +
	swap 1 core.rshift
	BRA:__unpackedNormalize_positive
ENDIF
dup __unpackedPositiveMantissa_mustShiftUp
IF
 	// check whether exponent is already at clip limit
	core.over 0x2F core.and 0x20 core.equals core.invert
	IF
		swap -1 +
		swap 1 core.lshift
		BRA:__unpackedNormalize_positive
	ENDIF
ENDIF
;
// 1: exponent; 0: mantissa
:__flm.unpackedNormalize
dup 
IF // mantissa is non-zero? YES
	dup 0x80000000 core.and 
	IF // mantissa is negative? YES
		__unpackedNormalize_negative     
	ELSE // mantissa is negative? NO
		__unpackedNormalize_positive
	ENDIF // mantissa is negative?
ELSE // mantissa is non-zero? NO
	swap drop 0
ENDIF // mantissa is zero?
;
:flm.unpack
// === mask to return stack ===
0x0000003F >r
// === extract exponent ===
dup r@ core.and 
// === negative sign extension ===
dup 0x00000020 core.and IF
0xFFFFFFC0 core.or 
ENDIF

// === extract mantissa ===
swap r> core.invert core.and
6 flm.rshiftArith
;
:flm.pack
6 core.lshift
swap
0x0000003F core.and
core.or
;
// returns number with n bits set, starting from bit 31
::__flm.nMsbMask core.invert 33 + 
1 swap core.lshift 
0 core.invert + core.invert ;

//arithmetic right shift (MSB replica stays in place)
:flm.rshiftArith
// special case:shift by 0 
core.dup 0 core.equals IF drop ; ENDIF
>r // store shift amount
r@ 32 core.lessThanSigned 
IF
	dup 0 <s 
	IF
		// shift and set new MSBs
		r@ __flm.nMsbMask swap r> core.rshift core.or ;
	ENDIF
	r> core.rshift ;
ENDIF
r> drop // clean up shift amount
0 core.lessThanSigned BZ:__flm.rshiftArithResultAllZero
0 core.invert ; // return 0xFFFFFFFF
:__flm.rshiftArithResultAllZero
0 ; // return 0x00000000
VAR:__flm.mantissaA=0
VAR:__flm.mantissaB=0
VAR:__flm.exponentA=0
VAR:__flm.exponentB=0


:flm.add
flm.unpack
'__flm.mantissaA ! '__flm.exponentA !
flm.unpack
'__flm.mantissaB ! '__flm.exponentB !

// === decide target exponent ===
'__flm.exponentA @ '__flm.exponentB @ <s 
IF
'__flm.exponentB @ 
ELSE
'__flm.exponentA @
ENDIF
>r

'__flm.mantissaA @
'__flm.exponentA @ core.invert 1 + r@ + flm.rshiftArith

'__flm.mantissaB @
'__flm.exponentB @ core.invert 1 + r@ + flm.rshiftArith

// === mantissa A and B are now aligned, common exponent in r@ ===
core.plus

r>		 // recall mantissa
swap		 // restore unpacked order

__flm.unpackedNormalize
flm.pack
;
:flm.mul
flm.unpack
'__flm.mantissaA ! '__flm.exponentA !
flm.unpack
'__flm.mantissaB ! '__flm.exponentB !

// === result exponent ===
'__flm.exponentA @ '__flm.exponentB @ + 32 +
// === result mantissa ===
'__flm.mantissaA @ '__flm.mantissaB @ math.s32*s32x2 drop
__flm.unpackedNormalize
flm.pack
;
