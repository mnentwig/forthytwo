VAR:math.scratch=0

// input u1 : modifA
// input u2 : acc
// input: multiplicandB in "math.scratch"
// output u2 : updated acc
// output u1 : new modifA
:__mul32step			// ( u2 u1 -- u2 u1 )
    CALL:__mul16step		// binary iteration for 2x 16 bits
:__mul16step CALL:__mul8step
:__mul8step CALL:__mul4step
:__mul4step CALL:__mul2step
:__mul2step CALL:__mulstep
:__mulstep
    >r 				// save modifA
    1 core.lshift		// shift acc further left
    r@ 0 <s IF			// test MSB of modifA (using signed comparison, sign bit set => negative)
        'math.scratch @ +	// if bit is set, add B to acc
    ENDIF 		
    r> 1 core.lshift		// restore modifA and shift
;

// input: A32 multiplicand
// input: B32 multiplicand
// output: product
:math.u32*u32		// ( u32 u32 -- u32 )
    'math.scratch !	// store B32
    0 swap 		// initialize acc
    __mul32step 	// run multiplication
    drop		// remove modified A
;
