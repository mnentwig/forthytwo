//|// ########################################################################
//|// # The file flm.txt is auto-generated by extractor.pl from flm.c
//|// # Its purpose is a system library for 32-bit pseudo-float math.
//|// # Public symbols are prefixed with the library name:
//|// # - flm.pack (build float from exponent and mantissa)
//|// # - flm.unpack (split float into exponent and mantissa)
//|// # - flm.add (add two floats)
//|// ########################################################################
//|// # (note, private symbol xyz is prefixed as __flm.xyz)

// C code in this fils is the reference implementation.

// "packed" format
// - 26-bit mantissa "M" including sign bit "S"
//   SMMMMMMM MMMMMMMM MMMMMMMM MMEEEEEE
// 84218421 84218421 84218421 84218421
// - 6-bit exponent (including exponent sign bit as MSB)
//
// normalization convention: The mantissa MSB (below the sign bit) is always active
// that is, set for positive, clear for negative numbers. Unlike IEEE float, it is NOT implied.
//
// "unpacked format": 6 additional mantissa MSBs "A" that must be normalized away before packing
// SAAAAAAM MMMMMMMM MMMMMMMM MMMMMMMM
// 84218421 84218421 84218421 84218421

// check for negative: if unpackedMantissa & 0x80000000
// negative_mustShiftDown : if unpackedMantissa & 0x7E000000 != 0x7E000000
// negative_mustShiftUp : if unpackedMantissa & 0x01000000 == 0
// positive_mustShiftDown: if unpackedMantissa & 0x7E000000 != 0
// positive_mustShiftUp: if unpackedMantissa & 0x01000000 == 0

int unpackedNegativeMantissa_mustShiftDown(int32_t mantissa){
  return (mantissa & 0x7E000000) != 0x7E000000;
}
//|::__unpackedNegativeMantissa_mustShiftDown 0x7E000000 dup >r core.and r> = core.invert ;

// =================================================================================================

int unpackedNegativeMantissa_mustShiftUp(int32_t mantissa){
  return mantissa & 0x01000000;
}
//|::__unpackedNegativeMantissa_mustShiftUp 0x01000000 core.and ;

// =================================================================================================

int unpackedPositiveMantissa_mustShiftDown(int32_t mantissa){
  return mantissa & 0x7E000000;
}
//|::__unpackedPositiveMantissa_mustShiftDown 0x7E000000 core.and ;

// =================================================================================================

int unpackedPositiveMantissa_mustShiftUp(int32_t mantissa){
  return (mantissa & 0x01000000) == 0;
}
//|::__unpackedPositiveMantissa_mustShiftUp 0x01000000 core.and 0 = ;

// =================================================================================================

void unpackedNormalize_negative(int32_t* mantissa, int32_t* exponent){
 again:
    if (unpackedNegativeMantissa_mustShiftDown(*mantissa)){
      *exponent = *exponent+1;
      *mantissa = *mantissa >> 1; // note: arithmetic shift
      goto again;
    }
    if (unpackedNegativeMantissa_mustShiftUp(*mantissa)){
      *exponent = *exponent-1;
      *mantissa = *mantissa << 1;
      goto again;
    }
}
//|:__unpackedNormalize_negative
//|dup __unpackedNegativeMantissa_mustShiftDown 
//|IF
//|	swap 1 +
//|	swap 1 core.rshift
//|	0x80000000 core.or
//|	BRA:__unpackedNormalize_negative
//|ENDIF
//|dup __unpackedNegativeMantissa_mustShiftUp
//|IF
//|	swap -1 +
//|	swap 1 core.lshift
//|	BRA:__unpackedNormalize_negative
//|ENDIF
//|;

// =================================================================================================

void unpackedNormalize_positive(int32_t* mantissa, int32_t* exponent){
 again:
    if (unpackedPositiveMantissa_mustShiftDown(*mantissa)){
      *exponent = *exponent+1;
      *mantissa = *mantissa >> 1;
      goto again;
    }
    if (unpackedPositiveMantissa_mustShiftUp(*mantissa)){
      *exponent = *exponent-1;
      *mantissa = *mantissa << 1;
      goto again;
    }
}

//|:__unpackedNormalize_positive
//|dup __unpackedPositiveMantissa_mustShiftDown 
//|IF
//|	swap 1 +
//|	swap 1 core.rshift
//|	BRA:__unpackedNormalize_positive
//|ENDIF
//|dup __unpackedPositiveMantissa_mustShiftUp
//|IF
//|	swap -1 +
//|	swap 1 core.lshift
//|	BRA:__unpackedNormalize_positive
//|ENDIF
//|;

// =================================================================================================

void unpackedNormalize(int32_t* mantissa, int32_t* exponent){
  //assert((*exponent >= -32) && (*exponent <= 31));
  if (*mantissa == 0)
    *exponent = 0;
  else if (*mantissa & 0x80000000)
    unpackedNormalize_negative(mantissa, exponent);
  else
    unpackedNormalize_positive(mantissa, exponent);
}

//|// 1: exponent; 0: mantissa
//|:__flm.unpackedNormalize
//|dup 
//|IF // mantissa is non-zero? YES
//|	dup 0x80000000 core.and 
//|	IF // mantissa is negative? YES
//|		__unpackedNormalize_negative     
//|	ELSE // mantissa is negative? NO
//|		__unpackedNormalize_positive
//|	ENDIF // mantissa is negative?
//|ELSE // mantissa is non-zero? NO
//|	swap drop 0
//|ENDIF // mantissa is zero?
//|;

// =================================================================================================

void flm_unpack(int32_t packed, int32_t* mantissa, int32_t* exponent){
  *exponent = packed & 0x3F;
  if (*exponent & 0x20)
    *exponent |= 0xFFFFFFC0;
  *mantissa = packed >> 6; // note, arithmetic shift
}

//|:flm.unpack
//|// === mask to return stack ===
//|0x0000003F >r
//|// === extract exponent ===
//|dup r@ core.and 
//|// === negative sign extension ===
//|dup 0x00000020 core.and IF
//|0xFFFFFFC0 core.or 
//|ENDIF
//|
//|// === extract mantissa ===
//|swap r> core.invert core.and
//|6 flm.rshiftArith
//|;

// =================================================================================================

void flm_pack(int32_t mantissa, int32_t exponent, int32_t* packed){
  *packed = (mantissa << 6) | (exponent & 0x3F);
}
//|:flm.pack
//|6 core.lshift
//|swap
//|0x0000003F core.and
//|core.or
//|;

// =================================================================================================

void flm_add(int32_t packedA, int32_t packedB, int32_t* result){
  int32_t mantissaA;
  int32_t exponentA;
  int32_t mantissaB;
  int32_t exponentB;
  flm_unpack(packedA, &mantissaA, &exponentA);
  flm_unpack(packedB, &mantissaB, &exponentB);
  //  printf("xxx%08x %08x %08x %08x \n", exponentA, mantissaA, exponentB, mantissaB);
  int32_t exponentResult = exponentA > exponentB ? exponentA : exponentB;
  mantissaA <<= (exponentResult-exponentA);
  mantissaB <<= (exponentResult-exponentB);
  int32_t mantissaResult = mantissaA + mantissaB;
  //printf("yyy%08x %08x\n", exponentResult, mantissaResult);

  unpackedNormalize(&mantissaResult, &exponentResult);
  //printf("zzz%08x %08x\n", exponentResult, mantissaResult);
  flm_pack(mantissaResult, exponentResult, result);
}

//|VAR:__flm.mantissaA=0
//|VAR:__flm.mantissaB=0
//|VAR:__flm.exponentA=0
//|VAR:__flm.exponentB=0

//|// returns number with n bits set, starting from bit 31
//|::__flm.nMsbMask core.invert 33 + 
//|1 swap core.lshift 
//|0 core.invert + core.invert ;
//|
//|//arithmetic right shift (MSB replica stays in place)
//|:flm.rshiftArith
//|>r 
//|dup 0 <s IF
//|r@ __flm.nMsbMask swap r> core.rshift core.or ;
//|ENDIF
//|r> core.rshift ;
//|
//|:flm.add
//|flm.unpack
//|'__flm.mantissaA ! '__flm.exponentA !
//|flm.unpack
//|'__flm.mantissaB ! '__flm.exponentB !
//|
//|// === decide target exponent ===
//|'__flm.exponentA @ '__flm.exponentB @ <s 
//|IF
//|'__flm.exponentB @ 
//|ELSE
//|'__flm.exponentA @
//|ENDIF
//|>r
//|
//|'__flm.mantissaA @
//|'__flm.exponentA @ core.invert 1 + r@ + core.lshift
//|
//|'__flm.mantissaB @
//|'__flm.exponentB @ core.invert 1 + r@ + core.lshift
//|
//|// === mantissa A and B are now aligned, common exponent in r@ ===
//|core.plus
//|
//|r>		 // recall mantissa
//|swap		 // restore unpacked order
//|
//|__flm.unpackedNormalize
//|flm.pack
//|;

#if false
double flm2double(int32_t val){
  int32_t exponent = (val << 26) >>> 26;
  int32_t mantissa = val >>> 6;
  double val = (double)mantissa;
  val = val * pow(2.0, exponent);
}

double double2flm(double val){
  uint32_t exponent = 0;
  if (val > 0){
    while (val >= (int32_t)0x7C00000){
      val /= 2; ++exponent;
    }
    while (val 
  } else {
    while (val < (int32_t)0xFC000000){
      val /= 2; ++exponent;
    }
  }
}
#endif
