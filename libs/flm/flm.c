#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <assert.h>

// xor-style LFSR pseudorandom sequences
#define SHIFT32(x)x ^= x << 13;	x ^= x >> 17; x ^= x << 5;

// NOTE:
// extractor.pl turns this into flm.txt
// (!!! this C file is NOT auto-generated, the comment will be written to file !!!)

//|// this file flm.txt is auto-generated by extractor.pl from flm.c
//|//address 0 (reset vector)
//|BRA:main // skip over code from included files
//|#include(../core.txt)
//|#include(../system.txt)
//|#include(../system.ASCII.txt)

static uint32_t arg1 = 0x12345678;
//|VAR:testMath.arg1=0x12345678 // state of LFSR1 pseudorandom number

static uint32_t arg2 = 0x98765432;
//|VAR:testMath.arg2=0x98765432 // state of LFSR2 pseudorandom number

//|// XOR-style LFSR permutation on the stack value
//|:testMath.LFSR32
//|	dup 13 core.lshift core.xor
//|	dup 17 core.rshift core.xor
//|	dup 5 core.lshift core.xor
//|;
//|
//|// applies LFSR32 on two variables
//|:__advanceBothLfsr 
//|	'testMath.arg1 @ testMath.LFSR32 'testMath.arg1 ! 
//|	'testMath.arg2 @ testMath.LFSR32 'testMath.arg2 ! 
//|;
//|
//|// recalls both LFSR variables
//|:__pushBothLfsr
//| 	'testMath.arg1 @ 
//|	'testMath.arg2 @
//|;
//|

// "packed" format
// - 26-bit mantissa "M" including sign bit "S"
//   SMMMMMMM MMMMMMMM MMMMMMMM MMEEEEEE
// 84218421 84218421 84218421 84218421
// - 6-bit exponent (including exponent sign bit as MSB)
//
// normalization convention: The mantissa MSB (below the sign bit) is always active
// that is, set for positive, clear for negative numbers. Unlike IEEE float, it is NOT implied.
//
// "unpacked format": 6 additional mantissa MSBs "A" that must be normalized away before packing
// SAAAAAAM MMMMMMMM MMMMMMMM MMMMMMMM
// 84218421 84218421 84218421 84218421

// check for negative: if unpackedMantissa & 0x80000000
// negative_mustShiftDown : if unpackedMantissa & 0x7E000000 != 0x7E000000
// negative_mustShiftUp : if unpackedMantissa & 0x01000000 == 0
// positive_mustShiftDown: if unpackedMantissa & 0x7E000000 != 0
// positive_mustShiftUp: if unpackedMantissa & 0x01000000 == 0

int isNegative(int32_t val){
  return val & 0x80000000;
}
//|::__isNegative 0x80000000 core.and ;

int unpackedNegativeMantissa_mustShiftDown(int32_t mantissa){
  return (mantissa & 0x7E000000) != 0x7E000000;
}
//|::__unpackedNegativeMantissa_mustShiftDown 0x7E000000 dup >r core.and r> = core.invert ;

int unpackedNegativeMantissa_mustShiftUp(int32_t mantissa){
  return mantissa & 0x01000000;
}
//|::__unpackedNegativeMantissa_mustShiftUp 0x01000000 core.and ;

int unpackedPositiveMantissa_mustShiftDown(int32_t mantissa){
  return mantissa & 0x7E000000;
}
//|::__unpackedPositiveMantissa_mustShiftDown 0x7E000000 core.and ;

int unpackedPositiveMantissa_mustShiftUp(int32_t mantissa){
  return (mantissa & 0x01000000) == 0;
}
//|::__unpackedPositiveMantissa_mustShiftUp 0x01000000 core.and 0 = ;

void unpackedNormalize_negative(int32_t* mantissa, int32_t* exponent){
 again:
    if (unpackedNegativeMantissa_mustShiftDown(*mantissa)){
      *exponent = *exponent+1;
      *mantissa = *mantissa >> 1; // note: arithmetic shift
      goto again;
    }
    if (unpackedNegativeMantissa_mustShiftUp(*mantissa)){
      *exponent = *exponent-1;
      *mantissa = *mantissa << 1;
      goto again;
    }
}
//|:__unpackedNormalize_negative
//|dup __unpackedNegativeMantissa_mustShiftDown 
//|IF
//|	swap 1 +
//|	swap 1 core.rshift
//|	0x80000000 core.or
//|	BRA:__unpackedNormalize_negative
//|ENDIF
//|dup __unpackedNegativeMantissa_mustShiftUp
//|IF
//|	swap -1 +
//|	swap 1 core.lshift
//|	BRA:__unpackedNormalize_negative
//|ENDIF
//|;

void unpackedNormalize_positive(int32_t* mantissa, int32_t* exponent){
 again:
    if (unpackedPositiveMantissa_mustShiftDown(*mantissa)){
      *exponent = *exponent+1;
      *mantissa = *mantissa >> 1;
      goto again;
    }
    if (unpackedPositiveMantissa_mustShiftUp(*mantissa)){
      *exponent = *exponent-1;
      *mantissa = *mantissa << 1;
      goto again;
    }
}
//|:__unpackedNormalize_positive
//|dup __unpackedPositiveMantissa_mustShiftDown 
//|IF
//|	swap 1 +
//|	swap 1 core.rshift
//|	BRA:__unpackedNormalize_positive
//|ENDIF
//|dup __unpackedPositiveMantissa_mustShiftUp
//|IF
//|	swap -1 +
//|	swap 1 core.lshift
//|	BRA:__unpackedNormalize_positive
//|ENDIF
//|;

void unpackedNormalize(int32_t* mantissa, int32_t* exponent){
  assert((*exponent >= -32) && (*exponent <= 31));
  if (*mantissa == 0)
    *exponent = 0;
  else if (*mantissa & 0x80000000)
    unpackedNormalize_negative(mantissa, exponent);
  else
    unpackedNormalize_positive(mantissa, exponent);
}
//|// 1: exponent; 0: mantissa
//|:__flm.unpackedNormalize
//|dup 
//|IF // mantissa is non-zero? YES
//|	dup 0x80000000 core.and 
//|	IF // mantissa is negative? YES
//|		__unpackedNormalize_negative     
//|	ELSE // mantissa is negative? NO
//|		__unpackedNormalize_positive
//|	ENDIF // mantissa is negative?
//|ELSE // mantissa is non-zero? NO
//|	swap drop 0
//|ENDIF // mantissa is zero?
//|;


#if false
double flm2double(int32_t val){
  int32_t exponent = (val << 26) >>> 26;
  int32_t mantissa = val >>> 6;
  double val = (double)mantissa;
  val = val * pow(2.0, exponent);
}

double double2flm(double val){
  uint32_t exponent = 0;
  if (val > 0){
    while (val >= (int32_t)0x7C00000){
      val /= 2; ++exponent;
    }
    while (val 
  } else {
    while (val < (int32_t)0xFC000000){
      val /= 2; ++exponent;
    }
  }
}
#endif

int main(void){    
  int ix;

  int32_t exponent; int32_t mantissa;

  //|:main

  mantissa = 0x00000000; exponent=1; unpackedNormalize(&mantissa, &exponent);
  printf("%08x %08x\n", mantissa, exponent);
  //|1 0x00000000 __flm.unpackedNormalize
  //|system.emit.hex8 system.emit.space 
  //|system.emit.hex8 system.emit.cr

  mantissa = 0x00000001; exponent=1; unpackedNormalize(&mantissa, &exponent);
  printf("%08x %08x\n", mantissa, exponent);
  //|1 0x00000001 __flm.unpackedNormalize
  //|system.emit.hex8 system.emit.space 
  //|system.emit.hex8 system.emit.cr

  for (ix = 0; ix < 32; ++ix){
    //|0 32 DO
    //|>r
    exponent = 0;
    //|0
    mantissa = 1 << ix;
    //|1 r@ core.lshift
    unpackedNormalize(&mantissa, &exponent);
    //|__flm.unpackedNormalize

    printf("%08x %08x\n", mantissa, exponent);
    //|system.emit.hex8 system.emit.space 
    //|system.emit.hex8 system.emit.cr
  }
  //|r>
  //|LOOP

  mantissa = 0x00000002; exponent=1; unpackedNormalize(&mantissa, &exponent);
  printf("%08x %08x\n", mantissa, exponent);
  //|1 0x00000002 __flm.unpackedNormalize
  //|system.emit.hex8 system.emit.space 
  //|system.emit.hex8 system.emit.cr

  for (ix = 0; ix < 100; ++ix){
    //|0 100 DO
    
    printf("%08x %08x ", arg1, arg2);
    //|// ====================================================
    //|// write col1:arg1; col2:arg2 (check LFSR state)
    //|// ====================================================
    //|__pushBothLfsr
    //|swap system.emit.hex8 system.emit.space 
    //|system.emit.hex8 system.emit.space
    
    // === update shift registers ===
    SHIFT32(arg1); SHIFT32(arg2);
    //|__advanceBothLfsr
    
    //|// ====================================================
    //|// end of line
    //|// ====================================================
    //|system.emit.cr
    printf("\n");
    
  } // for i
  //|LOOP
  
  return EXIT_SUCCESS;
  //|system.terminate
}
 
