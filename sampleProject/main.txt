// Fractal demo control code
// (c) Markus Nentwig 2019-2020

//address 0 (reset vector)

// this is a bootloader project:
#include(../refImpl/refImpl.srcs/bootloader.txt)

BRA:main // skip over code from included files
#include(../libs/core.txt)
#include(../libs/system.txt)
#include(../libs/system.ASCII.txt)
#include(../libs/math.txt)
#include(../libs/flm.txt)
#include(pointsImported.txt)
#include(driver.txt)
VAR:dataEnd=0xdeadbeef
VAR:dataPtrA=0xdeadbeef
VAR:dataPtrB=0xdeadbeef
VAR:x1=0
VAR:dx1=0
VAR:ddx1=0
VAR:y1=0
VAR:dy1=0
VAR:ddy1=0
VAR:x2=0
VAR:dx2=0
VAR:ddx2=0
VAR:y2=0
VAR:dy2=0
VAR:ddy2=0
VAR:nHalfSteps=150
VAR:lastFrameNum=0xFFFFFFFF

// note: frameCount is updated by the hardware immediately after the fractal parameters have been copied.
:waitForStartOfFrame
	driver.getButtons driver.setLEDs

	BEGIN
		//driver.getButtons
	UNTIL

	BEGIN
		'lastFrameNum @
		driver.getHardwareFrameNum
		core.equals
		core.invert
	UNTIL
	driver.getHardwareFrameNum
	'lastFrameNum
	!
;

// in 1:v1 0:v2
// out 1:v1 0:ddv 
:calcAcceleration	
	// v2-v1
	core.over
	flm.negate
	flm.add
	
	// 4*nSteps^2
	'nHalfSteps @ 0 core.lshift
	dup
	math.u32*u32
	flm.int2flt
	
	flm.div	
;

:varAddFltToVar
	@ over @ flm.add swap !
;

:fetchAndAdvanceDataPtr
	dup	// copy pointer address for store
	@	// retrieve data address
	dup @ >r // recall and save data
	4 + 	// advance data addresss
	dup 'dataEnd core.equals // check for end of data
	IF drop 'myData0 ENDIF // if yes, replace with start of data
	swap ! 	// store updated value
	r>	// return data
;

:loadNextPoint_fetchAndCalc
	'dataPtrA fetchAndAdvanceDataPtr // get start value
	'dataPtrB fetchAndAdvanceDataPtr // get stop value
	calcAcceleration
;

:flt2Q29 1 29 core.lshift flm.int2flt flm.mul flm.flt2int ;

:loadNextPointToInterpolators
	loadNextPoint_fetchAndCalc
	'ddx1 ! 'x1 ! 0 'dx1 !
	loadNextPoint_fetchAndCalc
	'ddy1 ! 'y1 ! 0 'dy1 !
	loadNextPoint_fetchAndCalc
	'ddx2 ! 'x2 ! 0 'dx2 !
	loadNextPoint_fetchAndCalc
	'ddy2 ! 'y2 ! 0 'dy2 !
;

:reverseAcceleration
	dup @ flm.negate swap !
;

:setX1X2Y1Y2
	  'x1 @ flt2Q29 
	  driver.fractal.setX
	  
	  'x2 @ 'x1 @ flm.negate flm.add 1919 flm.int2flt flm.div flt2Q29 
	  driver.fractal.setDX
	  
	  'y1 @ flt2Q29
	  driver.fractal.setY

	  'y2 @ 'y1 @ flm.negate flm.add 1079 flm.int2flt flm.div flt2Q29 
	  driver.fractal.setDY
;

:main
	system.ascii.1 system.uart.putChar system.emit.cr

	1 driver.fractal.onOff
	42 driver.fractal.setMaxiter

	// === init data pointers to first and second point in list ===
	'myData0 'dataPtrA !
	'myData4 'dataPtrB !

//	0 12 DO >r
BEGIN
	loadNextPointToInterpolators

	// === accelerating half ===
	0 'nHalfSteps @ DO >r
	  waitForStartOfFrame
	  setX1X2Y1Y2	

	  // == DEBUG: log the screen corners ===
	  //'x1 @ flm.emit system.emit.space
	  //'y1 @ flm.emit system.emit.space
	  //'x2 @ flm.emit system.emit.space
	  //'y2 @ flm.emit system.emit.cr

	  'dx1 'ddx1 varAddFltToVar
	  'x1 'dx1 varAddFltToVar

	  'dy1 'ddy1 varAddFltToVar
	  'y1 'dy1 varAddFltToVar

	  'dx2 'ddx2 varAddFltToVar
	  'x2 'dx2 varAddFltToVar

	  'dy2 'ddy2 varAddFltToVar
	  'y2 'dy2 varAddFltToVar
	r> LOOP

	// === change to deceleration ===
	'ddx1 reverseAcceleration
	'ddy1 reverseAcceleration
	'ddx2 reverseAcceleration
	'ddy2 reverseAcceleration

	// === decelerating part ===
	0 'nHalfSteps @ DO >r
	  waitForStartOfFrame
	  setX1X2Y1Y2	

	  'dx1 'ddx1 varAddFltToVar
	  'x1 'dx1 varAddFltToVar

	  'dy1 'ddy1 varAddFltToVar
	  'y1 'dy1 varAddFltToVar

	  'dx2 'ddx2 varAddFltToVar
	  'x2 'dx2 varAddFltToVar

	  'dy2 'ddy2 varAddFltToVar
	  'y2 'dy2 varAddFltToVar
	r> LOOP
AGAIN
//r> LOOP
//system.terminate
